<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>false</autorun>
 <autorun-early>false</autorun-early>
 <priority>0</priority>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>import pya
import os
import math

# -------------------------------------------------
# Configuration
# -------------------------------------------------
script_dir = os.path.dirname(os.path.abspath(__file__))
NMOS_ARRAY_GDS = os.path.join(script_dir, "nmos_array.gds")
NMOS_REF_GDS = os.path.join(script_dir, "nmos_reference.gds")
OUT_GDS = os.path.join(script_dir, "nmos_array_wafer.gds")

# Wafer Specs (Siegert Wafer BW16029 - 150mm)
WAFER_DIA_UM = 150000.0   # 150 mm
EDGE_EXCLUSION = 3000.0   # 3 mm margin
SCRIBE_GAP = 100.0        # Width of the street between dies

# SEMI Standard Flat for 150mm Wafer
# Length is typically 57.5mm +/- 2.5mm
FLAT_LENGTH_UM = 57500.0  
FLAT_POSITION = "BOTTOM"  # Primary flat is usually at the bottom for P&lt;100&gt;

# Dicing Mark Specs
MARK_SIZE = 80.0          
MARK_WIDTH = 10.0         

# Text Label Specs
LABEL_HEIGHT = 60.0       # Size of the coordinate text
LABEL_LAYER = 49          # Same as Metal (to be visible)

# Layer Definitions
def generate_layer_properties(output_gds_path):
    # This defines the visual style (Name, Layer, Datatype, Color)
    # Formats: (Name, Layer, Datatype, HexColor, FillPattern)
    # Fill patterns: 1=Solid, 3=Slash, 5=Cross, etc.
    layers_config = [
        ("ACTIVE",   43, 0, "#0000FF", 1), # Blue
        ("IMPLANT",  45, 0, "#00FF00", 5), # Green Empty
        ("POLY",     46, 0, "#FF0000", 3), # Red Slash
        ("CONTACT",  47, 0, "#000000", 1), # Black
        ("METAL",    49, 0, "#CC8800", 1), # Gold
        ("WAFER",    90, 0, "#808080", 5), # Gray Outline
        ("TEXT",     91, 0, "#000000", 0)  # Text
    ]
    
    lyp_path = output_gds_path.replace(".gds", ".lyp")
    
    with open(lyp_path, "w") as f:
        f.write('&lt;?xml version="1.0" encoding="utf-8"?&gt;\n')
        f.write('&lt;layer-properties&gt;\n')
        
        for name, lay, dt, color, dither in layers_config:
            f.write(' &lt;properties&gt;\n')
            f.write(f'  &lt;frame-color&gt;{color}&lt;/frame-color&gt;\n')
            f.write(f'  &lt;fill-color&gt;{color}&lt;/fill-color&gt;\n')
            f.write(f'  &lt;frame-brightness&gt;0&lt;/frame-brightness&gt;\n')
            f.write(f'  &lt;fill-brightness&gt;0&lt;/fill-brightness&gt;\n')
            f.write(f'  &lt;dither-pattern&gt;I{dither}&lt;/dither-pattern&gt;\n')
            f.write(f'  &lt;line-style/&gt;\n')
            f.write(f'  &lt;valid&gt;true&lt;/valid&gt;\n')
            f.write(f'  &lt;visible&gt;true&lt;/visible&gt;\n')
            f.write(f'  &lt;transparent&gt;false&lt;/transparent&gt;\n')
            f.write(f'  &lt;width/&gt;\n')
            f.write(f'  &lt;marked&gt;false&lt;/marked&gt;\n')
            f.write(f'  &lt;xfill&gt;false&lt;/xfill&gt;\n')
            f.write(f'  &lt;animation&gt;0&lt;/animation&gt;\n')
            f.write(f'  &lt;name&gt;{name} ({lay}/{dt})&lt;/name&gt;\n')
            f.write(f'  &lt;source&gt;{lay}/{dt}@1&lt;/source&gt;\n')
            f.write(' &lt;/properties&gt;\n')
            
        f.write('&lt;/layer-properties&gt;\n')
    print(f"Layer properties written to: {lyp_path}")

# -------------------------------------------------
# Load Source (ROBUST)
# -------------------------------------------------
ly = pya.Layout()

# 1. Load Standard Array
if not os.path.exists(NMOS_ARRAY_GDS):
    raise FileNotFoundError(f"Could not find source file: {NMOS_ARRAY_GDS}")
ly.read(NMOS_ARRAY_GDS)

# Safely find the Standard Cell Object
cell_std = ly.cell_by_name("NMOS_ARRAY")
if cell_std is None:
    # Fallback: Pick the first top cell found
    print("Warning: 'NMOS_ARRAY' cell not found by name. Using the first top cell.")
    cell_std = ly.top_cells()[0]

# 2. Load Reference Die (Fat FET)
if os.path.exists(NMOS_REF_GDS):
    ly.read(NMOS_REF_GDS)
    cell_ref = ly.cell_by_name("NMOS_FAT_FET")
    
    # Fallback: Find the new top cell that isn't the standard one
    if cell_ref is None:
        for tc in ly.top_cells():
            if tc.cell_index() != cell_std.cell_index():
                cell_ref = tc
                break
    if cell_ref is None:
        print("Warning: Reference loaded but cell not found. Using Standard Array.")
        cell_ref = cell_std
else:
    print("Warning: Reference GDS not found. Using Standard Array.")
    cell_ref = cell_std

# Set 'die' to the standard cell for pitch calculations
die = cell_std

# -------------------------------------------------
# Auto-detect Die Size
# -------------------------------------------------
l_metal_idx = ly.layer(49, 0)

# Check for INT vs OBJECT error
if isinstance(die, int):
    die = ly.cell(die) # Convert index back to object if needed

bbox = die.bbox_per_layer(l_metal_idx)
if bbox.empty():
    print("Warning: No metal found, falling back to full bbox")
    bbox = die.bbox()

die_w_um = bbox.width() * ly.dbu
die_h_um = bbox.height() * ly.dbu

print(f"Die Size: {die_w_um:.2f} x {die_h_um:.2f} µm")

# Pitch = Die Size + Scribe Lane
step_x_um = die_w_um + SCRIBE_GAP
step_y_um = die_h_um + SCRIBE_GAP

# -------------------------------------------------
# Auto-detect Die Size
# -------------------------------------------------
# Using Metal (49) to detect the true electrical boundary
l_metal_idx = ly.layer(49, 0)
bbox = die.bbox_per_layer(l_metal_idx)

if bbox.empty():
    print("Warning: No metal found, falling back to full bbox")
    bbox = die.bbox()

die_w_dbu = bbox.width()
die_h_dbu = bbox.height()

die_w_um = die_w_dbu * ly.dbu
die_h_um = die_h_dbu * ly.dbu

print(f"Die Size: {die_w_um:.2f} x {die_h_um:.2f} µm")

# Pitch = Die Size + Scribe Lane
step_x_um = die_w_um + SCRIBE_GAP
step_y_um = die_h_um + SCRIBE_GAP

# -------------------------------------------------
# Setup Wafer Cell
# -------------------------------------------------
wafer_top = ly.create_cell("WAFER_150MM")

# Layers
L_OUT   = ly.layer(90, 0)   # Wafer Outline
L_TXT   = ly.layer(91, 0)   # Info Text
L_METAL = ly.layer(LABEL_LAYER, 0) 

def um(v): 
    return int(round(v / ly.dbu))

# -------------------------------------------------
# Draw Wafer with Flat
# -------------------------------------------------
# Calculate the geometric "depth" of the flat
# R^2 = (Flat_Len/2)^2 + (Dist_to_Center)^2
R = WAFER_DIA_UM / 2.0
valid_R = R - EDGE_EXCLUSION

flat_half_len = FLAT_LENGTH_UM / 2.0
dist_to_flat = math.sqrt(R*R - flat_half_len*flat_half_len)

# Depending on position, we clip the polygon
flat_y_level = -dist_to_flat # Bottom flat

def draw_wafer_shape(cell, layer, radius, flat_y, points=360):
    pts = []
    for i in range(points):
        theta = 2 * math.pi * i / points
        x = radius * math.cos(theta)
        y = radius * math.sin(theta)
        
        # Clip Y at the flat level
        if y &lt; flat_y:
            # Snap to flat (simple approximation)
            # For exact intersection we would calculate X at flat_y
            # But for visual guide, simple clamping is usually fine 
            # or we filter points. Let's filter for better accuracy.
            continue 
            
        pts.append(pya.Point(um(x), um(y)))
    
    # Close the flat visually
    # Find start/end of the arc to close the chord
    # (The polygon logic closes first-to-last automatically, creating the flat line)
    cell.shapes(layer).insert(pya.Polygon(pts))

draw_wafer_shape(wafer_top, L_OUT, R, flat_y_level)
# Draw dashed guide for valid area (just a circle is fine for check)
# cell, layer, radius, num_points
pts_valid = [pya.Point(um(valid_R * math.cos(2*math.pi*i/64)), 
                       um(valid_R * math.sin(2*math.pi*i/64))) for i in range(64)]
wafer_top.shapes(L_OUT).insert(pya.Polygon(pts_valid))

# -------------------------------------------------
# Dicing Mark Helper
# -------------------------------------------------
def draw_cross(cell, layer, x_center, y_center, size, width):
    h_bar = pya.Box(
        um(x_center - size/2), um(y_center - width/2),
        um(x_center + size/2), um(y_center + width/2)
    )
    v_bar = pya.Box(
        um(x_center - width/2), um(y_center - size/2),
        um(x_center + width/2), um(y_center + size/2)
    )
    cell.shapes(layer).insert(h_bar)
    cell.shapes(layer).insert(v_bar)

# -------------------------------------------------
# Tiling &amp; Placement
# -------------------------------------------------
placed_marks = set()

def is_inside_valid_area(x, y, r_limit, flat_y):
    # Check Radius
    if (x*x + y*y) &gt; (r_limit * r_limit):
        return False
    # Check Flat (assuming bottom flat)
    if y &lt; flat_y + EDGE_EXCLUSION: # Keep margin from flat too
        return False
    return True

# Grid range
max_col = int(math.ceil(WAFER_DIA_UM / step_x_um))
max_row = int(math.ceil(WAFER_DIA_UM / step_y_um))

placed_count = 0

# -------------------------------------------------
# Tiling &amp; Placement with ROBUST TEXT
# -------------------------------------------------
placed_marks = set()
placed_count = 0

generator = pya.TextGenerator.default_generator()

# Text Parameters
TEXT_SIZE = 25.0       # Height of the letters (in um)
TEXT_LINE_WIDTH = 4.0  # Thickness of the stroke (in um)

# -------------------------------------------------
# Reference Die Selection Logic
# -------------------------------------------------
def is_ref_die_location(col, row):
    """
    Returns True if the (col, row) index should be a Reference Die.
    Strategy: 5-Point Map (Center + 4 Quadrants).
    """
    # 1. Center Die
    if col == 0 and row == 0:
        return True
    
    # 2. Quadrant Corners
    ref_index = 25
    if abs(col) == ref_index and abs(row) == ref_index:
        return True
        
    return False

# -------------------------------------------------
# Main logic loop
# -------------------------------------------------
# --- SANITY CHECK: Ensure we have Objects, not Integers ---
if isinstance(die, int): 
    die = ly.cell(die)
if isinstance(cell_ref, int): 
    cell_ref = ly.cell(cell_ref)

# --- PRE-CALCULATE INDICES (Fixes the AttributeError) ---
std_idx = die.cell_index()
ref_idx = cell_ref.cell_index()

# Setup Text Generator
generator = pya.TextGenerator.default_generator()
TEXT_SIZE = 25.0

for i in range(-max_col, max_col + 1):
    for j in range(-max_row, max_row + 1):
        
        cx = i * step_x_um
        cy = j * step_y_um
        
        hw = die_w_um / 2.0
        hh = die_h_um / 2.0
        
        # Check if die fits
        corners_in = True
        for dx, dy in [(-hw, -hh), (hw, -hh), (-hw, hh), (hw, hh)]:
            if not is_inside_valid_area(cx + dx, cy + dy, valid_R, flat_y_level):
                corners_in = False
                break
        
        if corners_in:
            # --- SELECTION LOGIC ---
            if is_ref_die_location(i, j):
                # USE REFERENCE CELL
                target_cell_idx = ref_idx     # Use pre-calculated index
                target_cell_obj = cell_ref    # Use object for bbox
                label_prefix = "REF "
            else:
                # USE STANDARD CELL
                target_cell_idx = std_idx     # Use pre-calculated index
                target_cell_obj = die         # Use object for bbox
                label_prefix = ""

            # Calculate centering based on the SPECIFIC cell object
            place_bbox = target_cell_obj.bbox_per_layer(l_metal_idx)
            if place_bbox.empty(): 
                place_bbox = target_cell_obj.bbox()

            place_center = place_bbox.center()

            # 1. Place the Die (Centered)
            shift_x = cx - place_center.x * ly.dbu
            shift_y = cy - place_center.y * ly.dbu
            
            trans = pya.Trans(um(shift_x), um(shift_y))
            wafer_top.insert(pya.CellInstArray(target_cell_idx, trans))
            placed_count += 1
            
            # 2. Add Coordinate Label
            label_str = f"{label_prefix}C{i} R{j}"
            text_region = generator.text(label_str, ly.dbu, TEXT_SIZE)
            text_w = text_region.bbox().width() * ly.dbu
            
            # Place label at top edge (Y + 90um)
            t_text = pya.Trans(um(cx - text_w/2.0), um(cy + 90.0))
            text_region.transform(t_text)
            wafer_top.shapes(L_METAL).insert(text_region)
            
            # 3. Dicing Marks
            mark_locs = [
                (cx - step_x_um/2, cy - step_y_um/2), 
                (cx + step_x_um/2, cy - step_y_um/2), 
                (cx - step_x_um/2, cy + step_y_um/2), 
                (cx + step_x_um/2, cy + step_y_um/2)  
            ]
            
            for (mx, my) in mark_locs:
                k = (int(round(mx)), int(round(my)))
                if k not in placed_marks:
                    if is_inside_valid_area(mx, my, R, flat_y_level):
                        draw_cross(wafer_top, L_METAL, mx, my, MARK_SIZE, MARK_WIDTH)
                        placed_marks.add(k)

# -------------------------------------------------
# Stats
# -------------------------------------------------
info_str = (f"Dies: {placed_count}\n"
            f"Step X/Y: {step_x_um:.1f} / {step_y_um:.1f}\n"
            f"Flat Y: {flat_y_level:.1f}")
            
t = pya.Text(info_str, pya.Trans(um(0), um(flat_y_level + 15000)))
t.halign = 1
t.size = um(2000)
wafer_top.shapes(L_TXT).insert(t)

ly.write(OUT_GDS)
generate_layer_properties(OUT_GDS)
print(f"Wafer generated: {OUT_GDS}")
print(f"Total Dies: {placed_count}")
print(f"Flat Position: Y &lt; {flat_y_level:.2f} um")
</text>
</klayout-macro>
