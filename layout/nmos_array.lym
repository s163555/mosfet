<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>false</autorun>
 <autorun-early>false</autorun-early>
 <priority>0</priority>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>import pya
import os
import sys

# Import Helper
script_dir = os.path.dirname(os.path.abspath(__file__))
if script_dir not in sys.path:
    sys.path.append(script_dir)
import layout_helper as h

OUTPUT_PATH = os.path.join(script_dir, "nmos_array.gds")

layout = pya.Layout()
layout.dbu = 0.001
top = layout.create_cell("NMOS_ARRAY")

# Layers
L_ACTIVE  = layout.layer(43, 0)
L_IMPLANT = layout.layer(45, 0)
L_POLY    = layout.layer(46, 0)
L_CONT    = layout.layer(47, 0)
L_METAL   = layout.layer(49, 0)
L_TEXT    = layout.layer(100, 0)

# Config
CONT_SZ = 3.0
CONT_SP = 3.0
CONT_ENC = 2.0
LANDING_PAD_SIZE = 15.0
WIRE_WIDTH = 15.0

ACTIVE_EXTENSION = 20.0
IMPLANT_ENCLOSURE = 5.0
POLY_EXT_ON_FIELD = 6.0
POLY_OVERHANG = 3.0
POLY_PAD_ENCLOSURE = 2.0

PAD_WIDTH = 100.0
PAD_HEIGHT = 100.0
PAD_SPACING = 150.0 

def draw_nmos(cell, x0, y0, L, W):
    # Draw Probe Pads
    px_offset = (PAD_WIDTH + PAD_SPACING) / 2
    py_offset = (PAD_HEIGHT + PAD_SPACING) / 2

    pads = {
        "S": (x0 - px_offset, y0 + py_offset), 
        "D": (x0 + px_offset, y0 + py_offset), 
        "G": (x0, y0 - py_offset)              
    }

    for name, (px, py) in pads.items():
        h.draw_box(layout, cell, L_METAL, px, py, PAD_WIDTH, PAD_HEIGHT)

    # Transistor Core
    # Define vertical limits
    poly_top = y0 + W/2 + POLY_OVERHANG
    poly_bot_edge = y0 - W/2 - POLY_EXT_ON_FIELD - LANDING_PAD_SIZE
    
    # Calculate Center of the Gate Pad
    g_cont_x = x0
    g_cont_y = poly_bot_edge + LANDING_PAD_SIZE/2

    # Calculate Poly Pad Size
    poly_pad_size = LANDING_PAD_SIZE + 2 * POLY_PAD_ENCLOSURE

    # A. Active Area
    act_w = L + 2 * ACTIVE_EXTENSION
    act_h = W
    h.draw_box(layout, cell, L_ACTIVE, x0, y0, act_w, act_h)

    # B. Implant Area (Updated to enclose the LARGER poly pad)
    imp_left = x0 - (act_w / 2) - IMPLANT_ENCLOSURE
    imp_right = x0 + (act_w / 2) + IMPLANT_ENCLOSURE
    imp_top = poly_top + IMPLANT_ENCLOSURE
    
    # Bottom limit must extend below the expanded poly pad
    poly_pad_bottom = g_cont_y - poly_pad_size/2
    imp_bottom = poly_pad_bottom - IMPLANT_ENCLOSURE 
    
    # Draw Implant using explicit box
    imp_box = pya.Box(h.um(layout, imp_left), h.um(layout, imp_bottom), 
                      h.um(layout, imp_right), h.um(layout, imp_top))
    cell.shapes(L_IMPLANT).insert(imp_box)

    # C. Poly Gate
    poly_box = pya.Box(
        h.um(layout, x0 - L/2), h.um(layout, poly_bot_edge),
        h.um(layout, x0 + L/2), h.um(layout, poly_top)
    )
    cell.shapes(L_POLY).insert(poly_box)

    # CONNECTIONS

    # A. Gate Connection
    if L &lt; poly_pad_size:
        h.draw_box(layout, cell, L_POLY, g_cont_x, g_cont_y, poly_pad_size, poly_pad_size)

    # Metal Pad Contacts
    h.fill_area_with_contacts(
        layout, cell, L_CONT, g_cont_x, g_cont_y, 
        LANDING_PAD_SIZE, LANDING_PAD_SIZE, 
        CONT_SZ, CONT_SP, CONT_ENC
    )
    
    h.draw_box(layout, cell, L_METAL, g_cont_x, g_cont_y, LANDING_PAD_SIZE, LANDING_PAD_SIZE)
    
    pg_x, pg_y = pads["G"]
    h.draw_wire(layout, cell, L_METAL, [
        (pg_x, pg_y + PAD_HEIGHT/2), 
        (g_cont_x, g_cont_y)         
    ], WIRE_WIDTH)


    # B. Source Connection
    src_x = x0 - L/2 - ACTIVE_EXTENSION/2
    
    h.fill_area_with_contacts(layout, cell, L_CONT, src_x, y0, LANDING_PAD_SIZE, LANDING_PAD_SIZE, CONT_SZ, CONT_SP, CONT_ENC)
    h.draw_box(layout, cell, L_METAL, src_x, y0, LANDING_PAD_SIZE, LANDING_PAD_SIZE)
    
    ps_x, ps_y = pads["S"]
    h.draw_wire(layout, cell, L_METAL, [
        (ps_x, ps_y - PAD_HEIGHT/2), 
        (ps_x, y0),                  
        (src_x, y0)                  
    ], WIRE_WIDTH)


    # C. Drain Connection
    drn_x = x0 + L/2 + ACTIVE_EXTENSION/2
    
    h.fill_area_with_contacts(
        layout, cell, L_CONT, drn_x, y0, 
        LANDING_PAD_SIZE, LANDING_PAD_SIZE, 
        CONT_SZ, CONT_SP, CONT_ENC
    )
    
    h.draw_box(layout, cell, L_METAL, drn_x, y0, LANDING_PAD_SIZE, LANDING_PAD_SIZE)
    
    pd_x, pd_y = pads["D"]
    h.draw_wire(layout, cell, L_METAL, [
        (pd_x, pd_y - PAD_HEIGHT/2), 
        (pd_x, y0),                  
        (drn_x, y0)                  
    ], WIRE_WIDTH)

    # D. Label
    label_text = f"L={L} W={W}"
    generator = pya.TextGenerator.default_generator()
    text_region = generator.text(label_text, layout.dbu, 12.0)
    
    text_bbox = text_region.bbox()
    text_width = text_bbox.width() * layout.dbu
    t_text = pya.Trans(h.um(layout, x0 - text_width/2.0), h.um(layout, y0 + 120.0))
    text_region.transform(t_text)
    cell.shapes(L_METAL).insert(text_region)

# Array Loop
Ls = [4, 6, 8, 10]
Ws = [20, 40, 60, 80]
DX, DY = 500.0, 500.0
for row, W in enumerate(Ws):
    for col, L in enumerate(Ls):
        draw_nmos(top, col*DX, -row*DY, L, W)

layout.write(OUTPUT_PATH)
print(f"Array written to {OUTPUT_PATH}")</text>
</klayout-macro>
