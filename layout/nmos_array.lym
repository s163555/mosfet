<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>false</autorun>
 <autorun-early>false</autorun-early>
 <priority>0</priority>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>import pya
import os
import sys

# Import Helper
script_dir = os.path.dirname(os.path.abspath(__file__))
if script_dir not in sys.path:
    sys.path.append(script_dir)
import layout_helper as h

OUTPUT_PATH = os.path.join(script_dir, "nmos_array.gds")

layout = pya.Layout()
layout.dbu = 0.001
top = layout.create_cell("NMOS_ARRAY")

# Layers
L_ACTIVE  = layout.layer(43, 0)
L_IMPLANT = layout.layer(45, 0)
L_POLY    = layout.layer(46, 0)
L_CONT    = layout.layer(47, 0)
L_METAL   = layout.layer(49, 0)
L_TEXT    = layout.layer(100, 0)

# Config
CONT_SZ = 3.0
CONT_SP = 3.0
CONT_ENC = 2.0
LANDING_PAD_SIZE = 15.0
WIRE_WIDTH = 15.0

ACTIVE_EXTENSION = 20.0
IMPLANT_ENCLOSURE = 5.0
POLY_EXT_ON_FIELD = 6.0    
POLY_OVERHANG = 3.0        

PAD_WIDTH = 100.0
PAD_HEIGHT = 100.0
PAD_SPACING = 150.0 

def draw_nmos(cell, x0, y0, L, W):
    # 1. Pads
    px_off = (PAD_WIDTH + PAD_SPACING) / 2
    py_off = (PAD_HEIGHT + PAD_SPACING) / 2
    pads = {
        "S": (x0 - px_off, y0 + py_off), 
        "D": (x0 + px_off, y0 + py_off), 
        "G": (x0, y0 - py_off)              
    }
    for p in pads.values():
        h.draw_box(layout, cell, L_METAL, p[0], p[1], PAD_WIDTH, PAD_HEIGHT)

    # 2. Core
    poly_top = y0 + W/2 + POLY_OVERHANG
    poly_bot_edge = y0 - W/2 - POLY_EXT_ON_FIELD - LANDING_PAD_SIZE
    
    act_w = L + 2 * ACTIVE_EXTENSION
    act_h = W
    h.draw_box(layout, cell, L_ACTIVE, x0, y0, act_w, act_h)

    # Implant
    imp_left = x0 - act_w/2 - IMPLANT_ENCLOSURE
    imp_right = x0 + act_w/2 + IMPLANT_ENCLOSURE
    imp_top = poly_top + IMPLANT_ENCLOSURE
    imp_bottom = poly_bot_edge - IMPLANT_ENCLOSURE
    # Using explicit box for asymmetrical implant
    imp_box = pya.Box(h.um(layout, imp_left), h.um(layout, imp_bottom), 
                      h.um(layout, imp_right), h.um(layout, imp_top))
    cell.shapes(L_IMPLANT).insert(imp_box)

    # Poly
    poly_box = pya.Box(h.um(layout, x0 - L/2), h.um(layout, poly_bot_edge),
                       h.um(layout, x0 + L/2), h.um(layout, poly_top))
    cell.shapes(L_POLY).insert(poly_box)

    # 3. Connections (Using Helper for Contacts)
    
    # Gate
    g_x, g_y = x0, poly_bot_edge + LANDING_PAD_SIZE/2
    if L &lt; LANDING_PAD_SIZE:
        h.draw_box(layout, cell, L_POLY, g_x, g_y, LANDING_PAD_SIZE, LANDING_PAD_SIZE)
        
    h.fill_area_with_contacts(layout, cell, L_CONT, g_x, g_y, 
                              LANDING_PAD_SIZE, LANDING_PAD_SIZE, CONT_SZ, CONT_SP, CONT_ENC)
    h.draw_box(layout, cell, L_METAL, g_x, g_y, LANDING_PAD_SIZE, LANDING_PAD_SIZE)
    h.draw_wire(layout, cell, L_METAL, [(pads["G"][0], pads["G"][1]+PAD_HEIGHT/2), (g_x, g_y)], WIRE_WIDTH)

    # Source
    s_x = x0 - L/2 - ACTIVE_EXTENSION/2
    h.fill_area_with_contacts(layout, cell, L_CONT, s_x, y0, 
                              LANDING_PAD_SIZE, LANDING_PAD_SIZE, CONT_SZ, CONT_SP, CONT_ENC)
    h.draw_box(layout, cell, L_METAL, s_x, y0, LANDING_PAD_SIZE, LANDING_PAD_SIZE)
    h.draw_wire(layout, cell, L_METAL, [(pads["S"][0], pads["S"][1]-PAD_HEIGHT/2), (pads["S"][0], y0), (s_x, y0)], WIRE_WIDTH)

    # Drain
    d_x = x0 + L/2 + ACTIVE_EXTENSION/2
    h.fill_area_with_contacts(layout, cell, L_CONT, d_x, y0, 
                              LANDING_PAD_SIZE, LANDING_PAD_SIZE, CONT_SZ, CONT_SP, CONT_ENC)
    h.draw_box(layout, cell, L_METAL, d_x, y0, LANDING_PAD_SIZE, LANDING_PAD_SIZE)
    h.draw_wire(layout, cell, L_METAL, [(pads["D"][0], pads["D"][1]-PAD_HEIGHT/2), (pads["D"][0], y0), (d_x, y0)], WIRE_WIDTH)

    # Label
    gen = pya.TextGenerator.default_generator()
    txt = gen.text(f"L={L} W={W}", layout.dbu, 12.0)
    w = txt.bbox().width() * layout.dbu
    txt.transform(pya.Trans(h.um(layout, x0 - w/2), h.um(layout, y0 + 120.0)))
    cell.shapes(L_METAL).insert(txt)

# Array Loop
Ls = [4, 6, 8, 10]
Ws = [20, 40, 60, 80]
DX, DY = 500.0, 500.0
for row, W in enumerate(Ws):
    for col, L in enumerate(Ls):
        draw_nmos(top, col*DX, -row*DY, L, W)

layout.write(OUTPUT_PATH)
print(f"Array written to {OUTPUT_PATH}")</text>
</klayout-macro>
