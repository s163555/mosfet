<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>false</autorun>
 <autorun-early>false</autorun-early>
 <priority>0</priority>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>import pya
import os
import math

# -------------------------------------------------
# Configuration
# -------------------------------------------------
script_dir = os.path.dirname(os.path.abspath(__file__))
SRC_GDS = os.path.join(script_dir, "nmos_array.gds")
OUT_GDS = os.path.join(script_dir, "nmos_array_wafer.gds")

# Wafer Specs (Siegert Wafer BW16029 - 150mm)
WAFER_DIA_UM = 150000.0   # 150 mm
EDGE_EXCLUSION = 3000.0   # 3 mm margin
SCRIBE_GAP = 100.0        # Width of the street between dies

# SEMI Standard Flat for 150mm Wafer
# Length is typically 57.5mm +/- 2.5mm
FLAT_LENGTH_UM = 57500.0  
FLAT_POSITION = "BOTTOM"  # Primary flat is usually at the bottom for P&lt;100&gt;

# Dicing Mark Specs
MARK_SIZE = 80.0          
MARK_WIDTH = 10.0         

# Text Label Specs
LABEL_HEIGHT = 60.0       # Size of the coordinate text
LABEL_LAYER = 49          # Same as Metal (to be visible)

# -------------------------------------------------
# Load Source
# -------------------------------------------------
if not os.path.exists(SRC_GDS):
    raise FileNotFoundError(f"Could not find source file: {SRC_GDS}")

ly = pya.Layout()
ly.read(SRC_GDS)
die = ly.top_cell()

# -------------------------------------------------
# Auto-detect Die Size
# -------------------------------------------------
# Using Metal (49) to detect the true electrical boundary
l_metal_idx = ly.layer(49, 0)
bbox = die.bbox_per_layer(l_metal_idx)

if bbox.empty():
    print("Warning: No metal found, falling back to full bbox")
    bbox = die.bbox()

die_w_dbu = bbox.width()
die_h_dbu = bbox.height()

die_w_um = die_w_dbu * ly.dbu
die_h_um = die_h_dbu * ly.dbu

print(f"Die Size: {die_w_um:.2f} x {die_h_um:.2f} Âµm")

# Pitch = Die Size + Scribe Lane
step_x_um = die_w_um + SCRIBE_GAP
step_y_um = die_h_um + SCRIBE_GAP

# -------------------------------------------------
# Setup Wafer Cell
# -------------------------------------------------
wafer_top = ly.create_cell("WAFER_150MM")

# Layers
L_OUT   = ly.layer(90, 0)   # Wafer Outline
L_TXT   = ly.layer(91, 0)   # Info Text
L_METAL = ly.layer(LABEL_LAYER, 0) 

def um(v): 
    return int(round(v / ly.dbu))

# -------------------------------------------------
# Draw Wafer with Flat
# -------------------------------------------------
# Calculate the geometric "depth" of the flat
# R^2 = (Flat_Len/2)^2 + (Dist_to_Center)^2
R = WAFER_DIA_UM / 2.0
valid_R = R - EDGE_EXCLUSION

flat_half_len = FLAT_LENGTH_UM / 2.0
dist_to_flat = math.sqrt(R*R - flat_half_len*flat_half_len)

# Depending on position, we clip the polygon
flat_y_level = -dist_to_flat # Bottom flat

def draw_wafer_shape(cell, layer, radius, flat_y, points=360):
    pts = []
    for i in range(points):
        theta = 2 * math.pi * i / points
        x = radius * math.cos(theta)
        y = radius * math.sin(theta)
        
        # Clip Y at the flat level
        if y &lt; flat_y:
            # Snap to flat (simple approximation)
            # For exact intersection we would calculate X at flat_y
            # But for visual guide, simple clamping is usually fine 
            # or we filter points. Let's filter for better accuracy.
            continue 
            
        pts.append(pya.Point(um(x), um(y)))
    
    # Close the flat visually
    # Find start/end of the arc to close the chord
    # (The polygon logic closes first-to-last automatically, creating the flat line)
    cell.shapes(layer).insert(pya.Polygon(pts))

draw_wafer_shape(wafer_top, L_OUT, R, flat_y_level)
# Draw dashed guide for valid area (just a circle is fine for check)
# cell, layer, radius, num_points
pts_valid = [pya.Point(um(valid_R * math.cos(2*math.pi*i/64)), 
                       um(valid_R * math.sin(2*math.pi*i/64))) for i in range(64)]
wafer_top.shapes(L_OUT).insert(pya.Polygon(pts_valid))

# -------------------------------------------------
# Dicing Mark Helper
# -------------------------------------------------
def draw_cross(cell, layer, x_center, y_center, size, width):
    h_bar = pya.Box(
        um(x_center - size/2), um(y_center - width/2),
        um(x_center + size/2), um(y_center + width/2)
    )
    v_bar = pya.Box(
        um(x_center - width/2), um(y_center - size/2),
        um(x_center + width/2), um(y_center + size/2)
    )
    cell.shapes(layer).insert(h_bar)
    cell.shapes(layer).insert(v_bar)

# -------------------------------------------------
# Tiling &amp; Placement
# -------------------------------------------------
placed_marks = set()

def is_inside_valid_area(x, y, r_limit, flat_y):
    # Check Radius
    if (x*x + y*y) &gt; (r_limit * r_limit):
        return False
    # Check Flat (assuming bottom flat)
    if y &lt; flat_y + EDGE_EXCLUSION: # Keep margin from flat too
        return False
    return True

# Grid range
max_col = int(math.ceil(WAFER_DIA_UM / step_x_um))
max_row = int(math.ceil(WAFER_DIA_UM / step_y_um))

placed_count = 0

# -------------------------------------------------
# Tiling &amp; Placement with ROBUST TEXT
# -------------------------------------------------
placed_marks = set()
placed_count = 0

generator = pya.TextGenerator.default_generator()

# Text Parameters
TEXT_SIZE = 25.0       # Height of the letters (in um)
TEXT_LINE_WIDTH = 4.0  # Thickness of the stroke (in um)

for i in range(-max_col, max_col + 1):
    for j in range(-max_row, max_row + 1):
        
        cx = i * step_x_um
        cy = j * step_y_um
        
        hw = die_w_um / 2.0
        hh = die_h_um / 2.0
        
        # Check if die fits
        corners_in = True
        for dx, dy in [(-hw, -hh), (hw, -hh), (-hw, hh), (hw, hh)]:
            if not is_inside_valid_area(cx + dx, cy + dy, valid_R, flat_y_level):
                corners_in = False
                break
        
        if corners_in:
            # 1. Place the Die (Centered)
            shift_x = cx - bbox.center().x * ly.dbu
            shift_y = cy - bbox.center().y * ly.dbu
            
            trans = pya.Trans(um(shift_x), um(shift_y))
            wafer_top.insert(pya.CellInstArray(die.cell_index(), trans))
            placed_count += 1
            
            # 2. Add Coordinate Label (ROBUST POLYGONS)
            label_str = f"C{i} R{j}"
            
            # Target Location: X=0, Y=+90 (relative to die center)
            # This places it exactly between the top two pads.
            
            # We create a transformation to move the text to (cx, cy + 90um)
            # We scale the text by 0.001 because the generator works in 'design units' (often 1/dbu)
            # but we want to specify size in um.
            
            # Generate the text region (polygons)
            # .text(string, database_unit, scale_factor)
            # We use a scale factor to set the text height
            text_region = generator.text(label_str, ly.dbu, TEXT_SIZE)
            
            # The text comes out at (0,0). We need to move it to the die location.
            # Center the text horizontally, move it up by 90um + cy
            text_bbox = text_region.bbox()
            text_width = text_bbox.width() * ly.dbu
            
            # Position: Centered at cx, and at Y = cy + 90um
            t_text = pya.Trans(um(cx - text_width/2.0), um(cy + -10.0))
            
            # Apply transform and insert into Wafer Cell
            # We must transform the region before inserting
            text_region.transform(t_text)
            wafer_top.shapes(L_METAL).insert(text_region)
            
            # 3. Dicing Marks
            mark_locs = [
                (cx - step_x_um/2, cy - step_y_um/2), 
                (cx + step_x_um/2, cy - step_y_um/2), 
                (cx - step_x_um/2, cy + step_y_um/2), 
                (cx + step_x_um/2, cy + step_y_um/2)  
            ]
            
            for (mx, my) in mark_locs:
                k = (int(round(mx)), int(round(my)))
                if k not in placed_marks:
                    if is_inside_valid_area(mx, my, R, flat_y_level):
                        draw_cross(wafer_top, L_METAL, mx, my, MARK_SIZE, MARK_WIDTH)
                        placed_marks.add(k)

# -------------------------------------------------
# Stats
# -------------------------------------------------
info_str = (f"Dies: {placed_count}\n"
            f"Step X/Y: {step_x_um:.1f} / {step_y_um:.1f}\n"
            f"Flat Y: {flat_y_level:.1f}")
            
t = pya.Text(info_str, pya.Trans(um(0), um(flat_y_level + 15000)))
t.halign = 1
t.size = um(2000)
wafer_top.shapes(L_TXT).insert(t)

ly.write(OUT_GDS)
print(f"Wafer generated: {OUT_GDS}")
print(f"Total Dies: {placed_count}")
print(f"Flat Position: Y &lt; {flat_y_level:.2f} um")</text>
</klayout-macro>
